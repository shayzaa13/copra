# Copyright cocotb contributors
# Licensed under the Revised BSD License, see LICENSE for details.
# SPDX-License-Identifier: BSD-3-Clause

"""Test stable ordering in generated stubs."""

import tempfile
from pathlib import Path

def test_stub_ordering_is_deterministic():
    """Test that generated stubs have deterministic ordering across multiple runs."""
    
    from copra.discovery import HierarchyDict, HDLNode
    from copra.generation import generate_stub
    
    hierarchy = HierarchyDict()
    
    test_signals = [
        ("z_signal", "cocotb.handle.LogicObject", False),
        ("a_signal", "cocotb.handle.LogicArrayObject", False), 
        ("m_signal", "cocotb.handle.LogicObject", False),
        ("b_bus", "cocotb.handle.HierarchyObject", True),
    ]
    
    for signal_name, py_type, is_scope in test_signals:
        node = HDLNode(
            path=f"dut.{signal_name}",
            py_type=py_type,
            width=8 if "Array" in py_type else 1,
            is_scope=is_scope
        )
        hierarchy._nodes[f"dut.{signal_name}"] = node  # type: ignore[reportPrivateUsage]
        hierarchy._build_tree_node(node)  # type: ignore[reportPrivateUsage]
    
    with tempfile.TemporaryDirectory() as temp_dir:
        temp_path = Path(temp_dir)

        stub_path1 = generate_stub(hierarchy, temp_path / "run1")
        content1 = stub_path1.read_text()
        
        stub_path2 = generate_stub(hierarchy, temp_path / "run2")
        content2 = stub_path2.read_text()
        
        stub_path3 = generate_stub(hierarchy, temp_path / "run3")
        content3 = stub_path3.read_text()
        
        assert content1 == content2 == content3, "Generated stubs should be deterministic across multiple runs"
        
        expected_content = """from __future__ import annotations
import cocotb.handle
import cocotb.types
from typing import overload, Literal
from typing import NewType

LogicArray8 = NewType("LogicArray8", cocotb.handle.LogicArrayObject)

# This file was automatically generated by copra
# It provides type stubs for your HDL design for use with cocotb

class Dut(cocotb.handle.HierarchyObject):
    a_signal: LogicArray8
    b_bus: BBus
    m_signal: cocotb.handle.LogicObject
    z_signal: cocotb.handle.LogicObject

    @overload
    def __getitem__(self, name: Literal['z_signal']) -> cocotb.handle.LogicObject: ...

    @overload
    def __getitem__(self, name: Literal['a_signal']) -> LogicArray8: ...

    @overload
    def __getitem__(self, name: Literal['m_signal']) -> cocotb.handle.LogicObject: ...

    @overload
    def __getitem__(self, name: Literal['b_bus']) -> BBus: ...

    @overload
    def __getitem__(self, name: str) -> cocotb.handle.SimHandleBase: ...

"""
        # Using strip() to ignore invisible trailing/leading whitespace differences
        assert content1.strip() == expected_content.strip(), "Generated stub content should match expected golden reference"


def test_many_signals_have_stable_ordering():
    """Test that many signals maintain alphabetical order."""
    
    from copra.discovery import HierarchyDict, HDLNode
    from copra.generation import generate_stub
    
    hierarchy = HierarchyDict()
    
    # Create signals in random order to test sorting
    signals = ["zebra", "alpha", "beta", "gamma", "delta", "omega", "sigma"] 
    for signal in signals:
        node = HDLNode(
            path=f"dut.{signal}",
            py_type="cocotb.handle.LogicObject", 
            width=1,
            is_scope=False
        )
        hierarchy._nodes[f"dut.{signal}"] = node  # type: ignore[reportPrivateUsage]
        hierarchy._build_tree_node(node)  # type: ignore[reportPrivateUsage]
    
    with tempfile.TemporaryDirectory() as temp_dir:
        temp_path = Path(temp_dir)
        stub_path = generate_stub(hierarchy, temp_path)
        content = stub_path.read_text()
        
        # Verify the content matches expected alphabetical ordering
        expected_content = """from __future__ import annotations
import cocotb.handle
import cocotb.types
from typing import overload, Literal
from typing import NewType


# This file was automatically generated by copra
# It provides type stubs for your HDL design for use with cocotb

class Dut(cocotb.handle.HierarchyObject):
    alpha: cocotb.handle.LogicObject
    beta: cocotb.handle.LogicObject
    delta: cocotb.handle.LogicObject
    gamma: cocotb.handle.LogicObject
    omega: cocotb.handle.LogicObject
    sigma: cocotb.handle.LogicObject
    zebra: cocotb.handle.LogicObject

    @overload
    def __getitem__(self, name: Literal['zebra']) -> cocotb.handle.LogicObject: ...

    @overload
    def __getitem__(self, name: Literal['alpha']) -> cocotb.handle.LogicObject: ...

    @overload
    def __getitem__(self, name: Literal['beta']) -> cocotb.handle.LogicObject: ...

    @overload
    def __getitem__(self, name: Literal['gamma']) -> cocotb.handle.LogicObject: ...

    @overload
    def __getitem__(self, name: Literal['delta']) -> cocotb.handle.LogicObject: ...

    @overload
    def __getitem__(self, name: Literal['omega']) -> cocotb.handle.LogicObject: ...

    @overload
    def __getitem__(self, name: Literal['sigma']) -> cocotb.handle.LogicObject: ...

    @overload
    def __getitem__(self, name: str) -> cocotb.handle.SimHandleBase: ...

"""
        # Using strip() to ignore invisible trailing/leading whitespace differences
        assert content.strip() == expected_content.strip(), "Generated stub should have signals in alphabetical order"